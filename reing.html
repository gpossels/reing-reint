<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analizador de Reingresos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .upload-section {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .file-input-wrapper label {
            font-weight: 600;
            color: #495057;
            min-width: 200px;
        }
        
        input[type="file"] {
            flex: 1;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            background: white;
            cursor: pointer;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .stats {
            padding: 20px 30px;
            background: #e9ecef;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            flex: 1;
            min-width: 140px;
        }
        
        .stat-label {
            font-size: 11px;
            color: #6c757d;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #495057;
        }
        
        .results-section {
            padding: 30px;
        }
        
        .collapsible-section {
            margin-bottom: 20px;
        }
        
        .collapsible-header {
            background: #495057;
            color: white;
            padding: 15px 20px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .collapsible-header::before {
            content: '‚ñº';
            transition: transform 0.3s;
        }
        
        .collapsible-section.collapsed .collapsible-header::before {
            transform: rotate(-90deg);
        }
        
        .collapsible-content {
            max-height: 10000px;
            overflow: visible;
            padding-top: 20px;
            transition: max-height 0.3s;
        }
        
        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            overflow: hidden;
            padding-top: 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        thead {
            background: #495057;
            color: white;
        }
        
        th {
            padding: 12px 8px;
            text-align: left;
            font-size: 10px;
            text-transform: uppercase;
        }
        
        td {
            padding: 10px 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .highlight-red {
            background-color: #ffe6e6;
        }
        
        .highlight-green {
            background-color: #d4f4dd;
        }
        
        .highlight-yellow {
            background-color: #fff3cd;
        }
        
        .patient-group {
            border-top: 3px solid #667eea;
        }
        
        .filter-section {
            margin: 15px 0;
        }
        
        .filter-section select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè• Analizador de Reingresos</h1>
            <p>Detecci√≥n de reingresos hospitalarios no planificados (ventana de 30 d√≠as)</p>
        </div>
        
        <div class="upload-section">
            <div class="file-input-wrapper">
                <label for="reingresosFile">üìã Archivo de Reingresos:</label>
                <input type="file" id="reingresosFile" accept=".xlsx,.xls" />
            </div>
            <div class="file-input-wrapper">
                <label for="reintervencionesFile">üî™ Archivo de Reintervenciones (Opcional):</label>
                <input type="file" id="reintervencionesFile" accept=".xlsx,.xls" />
            </div>
            <button class="btn" id="analyzeBtn" disabled>Analizar Datos</button>
        </div>
        
        <div id="statsSection" style="display: none;" class="stats">
            <div class="stat-item">
                <div class="stat-label">Total Inicial</div>
                <div class="stat-value" id="totalInicial">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Pacientes √önicos</div>
                <div class="stat-value" id="uniquePatients">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Descartados (Sin mes actual)</div>
                <div class="stat-value" id="discardedNoMonth">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Reingresos Finales</div>
                <div class="stat-value" id="finalRecords">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üî¥ Con Cirug√≠a</div>
                <div class="stat-value" id="withSurgery" style="color: #dc3545;">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üü° Con Alertas Amarillas</div>
                <div class="stat-value" id="withYellowAlerts" style="color: #ffc107;">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üü¢ Con Alertas</div>
                <div class="stat-value" id="withAlerts" style="color: #28a745;">0</div>
            </div>
        </div>
        
        <div id="resultsSection" class="results-section" style="display: none;">
            <div class="collapsible-section collapsed">
                <div class="collapsible-header" onclick="toggleSection(this)">
                    üìã Listado Filtrado (Reingresos Procesados)
                </div>
                <div class="collapsible-content">
                    <div class="filter-section">
                        <label>Filtrar: </label>
                        <select id="filterSelect" onchange="applyFilter()">
                            <option value="all">Todos</option>
                            <option value="red">Solo con cirug√≠a / alertas rojas</option>
                            <option value="yellow">Solo con alertas amarillas</option>
                            <option value="green">Solo con alertas verdes</option>
                            <option value="white">Solo sin alertas</option>
                        </select>
                    </div>
                    <table id="resultsTable">
                        <thead>
                            <tr>
                                <th>RUT</th>
                                <th>Nombre</th>
                                <th>Edad</th>
                                <th>Sexo</th>
                                <th>Cama Asignada</th>
                                <th>Prestaci√≥n Realizada</th>
                                <th>ID Ingreso</th>
                                <th>Fecha Egreso</th>
                                <th>Fecha Reingreso</th>
                                <th>D√≠as</th>
                                <th>Diagn√≥stico</th>
                                <th>ID Reingreso</th>
                                <th>Cirug√≠a</th>
                                <th><input type="checkbox" id="checkAllFiltered" onchange="toggleAllFiltered()"> Marcar</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                    <button class="btn" onclick="downloadMarked()" style="margin-top: 20px;">üì• Descargar Marcados</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let reingresosData = null;
        let reintervencionesData = null;
        let allRecords = [];
        
        document.getElementById('reingresosFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const workbook = XLSX.read(e.target.result, { type: 'binary' });
                    const possibleSheets = ['Exportar Hoja de Trabajo', 'MEDIC'];
                    const sheetName = possibleSheets.find(name => workbook.Sheets[name]) || workbook.SheetNames.find(n => n !== 'SQL') || workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    reingresosData = XLSX.utils.sheet_to_json(sheet);
                    checkReady();
                };
                reader.readAsBinaryString(file);
            }
        });
        
        document.getElementById('reintervencionesFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const workbook = XLSX.read(e.target.result, { type: 'binary' });
                    const sheetName = workbook.SheetNames.find(n => n !== 'SQL') || workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    reintervencionesData = XLSX.utils.sheet_to_json(sheet);
                    checkReady();
                };
                reader.readAsBinaryString(file);
            }
        });
        
        function checkReady() {
            document.getElementById('analyzeBtn').disabled = !reingresosData;
        }
        
        document.getElementById('analyzeBtn').addEventListener('click', analyzeData);
        
        function parseDate(dateStr) {
            if (!dateStr) return null;
            if (typeof dateStr === 'number') {
                return new Date(1899, 11, 30 + dateStr);
            }
            if (typeof dateStr === 'string') {
                const parts = dateStr.split(/[\/\-\s:]/);
                if (parts.length >= 3) {
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1;
                    let year = parseInt(parts[2]);
                    if (year < 100) year += year < 50 ? 2000 : 1900;
                    return new Date(year, month, day);
                }
            }
            if (dateStr instanceof Date) return dateStr;
            return null;
        }
        
        function formatDate(date) {
            const d = parseDate(date);
            if (!d) return '';
            return `${String(d.getDate()).padStart(2,'0')}/${String(d.getMonth()+1).padStart(2,'0')}/${d.getFullYear()}`;
        }
        
        function getDays(d1, d2) {
            const date1 = parseDate(d1);
            const date2 = parseDate(d2);
            if (!date1 || !date2) return null;
            return Math.floor((date2 - date1) / 86400000);
        }
        
        function getYearMonth(date) {
            const d = parseDate(date);
            if (!d) return null;
            return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
        }
        
        function analyzeData() {
            const totalInicial = reingresosData.length;
            
            // Find most recent month
            let mostRecent = null;
            reingresosData.forEach(r => {
                const d = parseDate(r.FECHA_REING);
                if (d && (!mostRecent || d > mostRecent)) mostRecent = d;
            });
            
            const lastMonth = getYearMonth(mostRecent);
            
            // Group by patient
            const patients = {};
            reingresosData.forEach(r => {
                const rut = r.RUT_PACIENTE;
                if (!patients[rut]) patients[rut] = [];
                patients[rut].push(r);
            });
            
            // Filter patients - REMOVED SINGLE RECORD RULE
            let discardedNoMonth = 0;
            const validPatients = {};
            
            Object.entries(patients).forEach(([rut, records]) => {
                const hasRecent = records.some(r => getYearMonth(r.FECHA_REING) === lastMonth);
                if (!hasRecent) {
                    discardedNoMonth += records.length;
                    return;
                }
                validPatients[rut] = records;
            });
            
            // Build sequential chains: each discharge pairs with immediate next readmission
            // Only if no other discharge exists between them
            const paired = [];
            
            Object.values(validPatients).forEach(records => {
                // Get unique discharges sorted by date
                const uniqueDischarges = [];
                const seenDischarges = new Set();
                
                records.forEach(r => {
                    if (r.ID_INGRESO && r.FECHA_EGRESO) {
                        const key = `${r.ID_INGRESO}-${formatDate(r.FECHA_EGRESO)}`;
                        if (!seenDischarges.has(key)) {
                            seenDischarges.add(key);
                            uniqueDischarges.push({
                                id: r.ID_INGRESO,
                                date: parseDate(r.FECHA_EGRESO),
                                record: r
                            });
                        }
                    }
                });
                
                // Get unique readmissions sorted by date
                const uniqueReadmissions = [];
                const seenReadmissions = new Set();
                
                records.forEach(r => {
                    if (r.ID_REINGRESO && r.FECHA_REING) {
                        const key = `${r.ID_REINGRESO}-${formatDate(r.FECHA_REING)}`;
                        if (!seenReadmissions.has(key)) {
                            seenReadmissions.add(key);
                            uniqueReadmissions.push({
                                id: r.ID_REINGRESO,
                                date: parseDate(r.FECHA_REING)
                            });
                        }
                    }
                });
                
                // Sort chronologically
                uniqueDischarges.sort((a, b) => a.date - b.date);
                uniqueReadmissions.sort((a, b) => a.date - b.date);
                
                // Get all discharge IDs that also exist as readmission IDs (chain links)
                const dischargeIds = new Set(uniqueDischarges.map(d => d.id));
                
                // For each discharge, find the immediate next readmission
                // But only if no other discharge exists between them
                uniqueDischarges.forEach((discharge, index) => {
                    const dischargeDate = discharge.date;
                    const dischargeId = discharge.id;
                    
                    // Find the first readmission after this discharge
                    const nextReadmission = uniqueReadmissions.find(r => r.date > dischargeDate);
                    
                    if (!nextReadmission) return;
                    
                    // Check if there's another discharge between this discharge and the readmission
                    const hasIntermediateDischarge = uniqueDischarges.some((d, i) => 
                        i > index && d.date > dischargeDate && d.date < nextReadmission.date
                    );
                    
                    // Skip this pair if there's an intermediate discharge
                    if (hasIntermediateDischarge) return;
                    
                    const dias = getDays(dischargeDate, nextReadmission.date);
                    
                    // Include if within 30 days AND (readmission is also a discharge OR it's the final readmission)
                    const isChainLink = dischargeIds.has(nextReadmission.id);
                    const isFinalReadmission = uniqueReadmissions.indexOf(nextReadmission) === uniqueReadmissions.length - 1;
                    
                    if (dias !== null && dias > 0 && dias <= 30 && (isChainLink || isFinalReadmission)) {
                        // Find the original record with this exact pairing
                        const matchingRecord = records.find(r => 
                            r.ID_INGRESO === dischargeId &&
                            formatDate(r.FECHA_EGRESO) === formatDate(dischargeDate) &&
                            r.ID_REINGRESO === nextReadmission.id &&
                            formatDate(r.FECHA_REING) === formatDate(nextReadmission.date)
                        );
                        
                        if (matchingRecord) {
                            paired.push({
                                ...matchingRecord,
                                dias: dias
                            });
                        }
                    }
                });
            });
            
            // Match with surgeries
            const surgeryIndex = {};
            if (reintervencionesData) {
                reintervencionesData.forEach(s => {
                    const id = s.ID_INGRESO;
                    if (id) {
                        if (!surgeryIndex[id]) surgeryIndex[id] = [];
                        surgeryIndex[id].push(s);
                    }
                });
            }
            
            const patientsWithSurgery = new Set();
            const patientsWithAlert = new Set();
            const patientsWithRedAlert = new Set();
            const patientsWithYellowAlert = new Set();
            
            paired.forEach(r => {
                const id = r.ID_REINGRESO;
                if (id && surgeryIndex[id]) {
                    r.surgeries = surgeryIndex[id];
                    r.hasSurgery = true;
                    patientsWithSurgery.add(r.RUT_PACIENTE);
                } else {
                    r.surgeries = [];
                    r.hasSurgery = false;
                }
                
                // Check for red alert conditions (diagnoses)
                const hasDolorAgudo = r.DIAGNOSTICO_EGRESO === 'DOLOR AGUDO';
                const hasEmboliaPulmonar = r.DIAGNOSTICO_EGRESO === 'EMBOLIA PULMONAR';
                const hasEmboliaVena = r.DIAGNOSTICO_EGRESO === 'EMBOLIA Y TROMBOSIS DE VENA NO ESPECIFICADA';
                
                // Check for red alert conditions (prestaciones)
                const hasLaparotomia = r.NOMBRE_PRESTACION_INGRESO === 'LAP-LAPAROTOMIA EXPLORADA';
                
                if (hasDolorAgudo || hasEmboliaPulmonar || hasEmboliaVena || hasLaparotomia) {
                    r.hasRedAlert = true;
                    patientsWithRedAlert.add(r.RUT_PACIENTE);
                }
                
                // Check for yellow alert conditions (prestaciones)
                const hasReconstitucion = r.NOMBRE_PRESTACION_INGRESO === 'RECONSTITUCION  TRANSITO POST OPERACION';
                const hasEndoprotesis = r.NOMBRE_PRESTACION_INGRESO === 'ENDOPROTESIS TOTAL DE CADERA';
                
                if (hasReconstitucion || hasEndoprotesis) {
                    r.hasYellowAlert = true;
                    patientsWithYellowAlert.add(r.RUT_PACIENTE);
                }
                
                // Check for green alert conditions
                const hasBoxTransitorio = r.DESC_COD_CAMA === 'BOX TRANSITORIO 0 -3 HRS';
                const hasMucopolisacaridosis = 
                    r.DIAGNOSTICO_EGRESO === 'MUCOPOLISACARIDOSIS NO ESPECIFICADA' ||
                    r.DIAGNOSTICO_EGRESO === 'MUCOPOLISACARIDOSIS TIPO I';
                const hasCateterInstallation = r.NOMBRE_PRESTACION_INGRESO === 'INSTALACION CATETER RESERV SUB CUT QMT';
                const hasAberturaArtificial = r.DIAGNOSTICO_EGRESO === 'ABERTURA ARTIFICIAL, NO ESPECIFICADA';
                
                // Check for green alert conditions (prestaciones)
                const hasColecistectomia = r.NOMBRE_PRESTACION_INGRESO === 'COLECISTECTOMIA POR VIDEOLAPAROSCOPIA';
                const hasHemorroidectomia = r.NOMBRE_PRESTACION_INGRESO === 'HEMORROIDECTOMIA (INCLUYE OTRAS OPERA-';
                const hasGinecomastia = r.NOMBRE_PRESTACION_INGRESO === 'GINECOMASTIA, CORRECCION PLASTICA';
                const hasVasectomia = r.NOMBRE_PRESTACION_INGRESO === 'VASECTOMIA BILATERAL, (PROC. AUT.) (LA V';
                
                if (hasBoxTransitorio || hasMucopolisacaridosis || hasCateterInstallation || hasAberturaArtificial ||
                    hasColecistectomia || hasHemorroidectomia || hasGinecomastia || hasVasectomia) {
                    r.hasAlert = true;
                    patientsWithAlert.add(r.RUT_PACIENTE);
                }
            });
            
            paired.forEach(r => {
                if (patientsWithSurgery.has(r.RUT_PACIENTE) || patientsWithRedAlert.has(r.RUT_PACIENTE)) {
                    r.markRed = true;
                }
                if (patientsWithYellowAlert.has(r.RUT_PACIENTE)) r.markYellow = true;
                if (patientsWithAlert.has(r.RUT_PACIENTE)) r.markGreen = true;
            });
            
            paired.sort((a,b) => {
                if (a.markRed && !b.markRed) return -1;
                if (!a.markRed && b.markRed) return 1;
                if (a.markYellow && !b.markYellow) return -1;
                if (!a.markYellow && b.markYellow) return 1;
                if (a.markGreen && !b.markGreen) return -1;
                if (!a.markGreen && b.markGreen) return 1;
                return String(a.RUT_PACIENTE).localeCompare(String(b.RUT_PACIENTE));
            });
            
            allRecords = paired;
            
            // Update stats
            document.getElementById('totalInicial').textContent = totalInicial;
            document.getElementById('uniquePatients').textContent = Object.keys(patients).length;
            document.getElementById('discardedNoMonth').textContent = discardedNoMonth;
            document.getElementById('finalRecords').textContent = paired.length;
            document.getElementById('withSurgery').textContent = paired.filter(r => r.markRed).length;
            document.getElementById('withYellowAlerts').textContent = paired.filter(r => r.markYellow).length;
            document.getElementById('withAlerts').textContent = paired.filter(r => r.markGreen).length;
            
            document.getElementById('statsSection').style.display = 'flex';
            document.getElementById('resultsSection').style.display = 'block';
            
            displayTable(paired);
        }
        
        function displayTable(records) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            let currentRut = null;
            
            records.forEach(r => {
                const tr = document.createElement('tr');
                if (currentRut !== r.RUT_PACIENTE) {
                    tr.classList.add('patient-group');
                    currentRut = r.RUT_PACIENTE;
                }
                if (r.markRed) tr.classList.add('highlight-red');
                else if (r.markYellow) tr.classList.add('highlight-yellow');
                else if (r.markGreen) tr.classList.add('highlight-green');
                
                const surgeryInfo = r.surgeries && r.surgeries.length > 0
                    ? r.surgeries.map(s => `${s.PRESTACION || 'N/A'}`).join('; ')
                    : '-';
                
                tr.innerHTML = `
                    <td>${r.RUT_PACIENTE || ''}</td>
                    <td>${r.NOMBRE_PACIENTE || ''}</td>
                    <td>${r.EDAD || ''}</td>
                    <td>${r.SEXO_PACIENTE || ''}</td>
                    <td>${r.DESC_COD_CAMA || ''}</td>
                    <td>${r.NOMBRE_PRESTACION_INGRESO || ''}</td>
                    <td>${r.ID_INGRESO || ''}</td>
                    <td>${formatDate(r.FECHA_EGRESO)}</td>
                    <td>${formatDate(r.FECHA_REING)}</td>
                    <td><strong>${r.dias}</strong></td>
                    <td>${r.DIAGNOSTICO_EGRESO || ''}</td>
                    <td>${r.ID_REINGRESO || ''}</td>
                    <td>${surgeryInfo}</td>
                    <td><input type="checkbox" class="row-checkbox-filtered" data-id="${r.RUT_PACIENTE}-${r.ID_REINGRESO}"></td>
                `;
                tbody.appendChild(tr);
            });
        }
        
        function toggleAllFiltered() {
            const masterCheckbox = document.getElementById('checkAllFiltered');
            const checkboxes = document.querySelectorAll('.row-checkbox-filtered');
            checkboxes.forEach(cb => {
                cb.checked = masterCheckbox.checked;
            });
        }
        
        function toggleSection(header) {
            header.parentElement.classList.toggle('collapsed');
        }
        
        function applyFilter() {
            const filter = document.getElementById('filterSelect').value;
            let filtered = allRecords;
            
            if (filter === 'red') {
                const pats = new Set(allRecords.filter(r => r.markRed).map(r => r.RUT_PACIENTE));
                filtered = allRecords.filter(r => pats.has(r.RUT_PACIENTE));
            } else if (filter === 'yellow') {
                const pats = new Set(allRecords.filter(r => r.markYellow && !r.markRed).map(r => r.RUT_PACIENTE));
                filtered = allRecords.filter(r => pats.has(r.RUT_PACIENTE));
            } else if (filter === 'green') {
                const pats = new Set(allRecords.filter(r => r.markGreen && !r.markRed && !r.markYellow).map(r => r.RUT_PACIENTE));
                filtered = allRecords.filter(r => pats.has(r.RUT_PACIENTE));
            } else if (filter === 'white') {
                const pats = new Set(allRecords.filter(r => !r.markRed && !r.markYellow && !r.markGreen).map(r => r.RUT_PACIENTE));
                filtered = allRecords.filter(r => pats.has(r.RUT_PACIENTE));
            }
            
            displayTable(filtered);
        }
        
        function downloadMarked() {
            const checked = Array.from(document.querySelectorAll('.row-checkbox-filtered:checked'));
            if (checked.length === 0) {
                alert('No hay filas marcadas');
                return;
            }
            
            const data = [['RUT', 'Nombre', 'Edad', 'Sexo', 'Cama_Asignada', 'Prestacion_Realizada', 'ID_Ingreso', 'Fecha_Egreso', 'Fecha_Reingreso', 'Dias', 'Diagnostico', 'ID_Reingreso', 'Cirugia']];
            
            checked.forEach(cb => {
                const row = cb.closest('tr');
                const cells = row.querySelectorAll('td');
                data.push([
                    cells[0].textContent,
                    cells[1].textContent,
                    cells[2].textContent,
                    cells[3].textContent,
                    cells[4].textContent,
                    cells[5].textContent,
                    cells[6].textContent,
                    cells[7].textContent,
                    cells[8].textContent,
                    cells[9].textContent,
                    cells[10].textContent,
                    cells[11].textContent,
                    cells[12].textContent
                ]);
            });
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(data);
            XLSX.utils.book_append_sheet(wb, ws, 'Reingresos');
            XLSX.writeFile(wb, `Reingresos_${new Date().toISOString().slice(0,10)}.xlsx`);
        }
    </script>
</body>
</html>
